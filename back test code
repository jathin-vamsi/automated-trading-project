import math
import pandas as pd
from binance.client import Client
from datetime import datetime

# ========== CONFIG ==========
SYMBOL = "XRPUSDT"
TIMEFRAME = Client.KLINE_INTERVAL_15MINUTE
START_DATE = "2023-01-01"
END_DATE = "2023-06-01"

START_BALANCE = 1000
LEVERAGE = 25
RISK_PERCENT = 0.25

EMA_SHORT = 9
EMA_LONG = 21
RSI_PERIOD = 7
MACD_SHORT = 5
MACD_LONG = 13

# ========== BINANCE CLIENT (NO KEYS NEEDED) ==========
client = Client()

# ========== INDICATORS ==========
def rsi(series, period):
    delta = series.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.rolling(period).mean()
    avg_loss = loss.rolling(period).mean()
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

def indicators(df):
    df["EMA_S"] = df["close"].ewm(span=EMA_SHORT, adjust=False).mean()
    df["EMA_L"] = df["close"].ewm(span=EMA_LONG, adjust=False).mean()
    df["RSI"] = rsi(df["close"], RSI_PERIOD)
    df["MACD"] = (
        df["close"].ewm(span=MACD_SHORT, adjust=False).mean()
        - df["close"].ewm(span=MACD_LONG, adjust=False).mean()
    )
    return df

# ========== LOAD REAL HISTORICAL DATA ==========
klines = client.get_historical_klines(
    SYMBOL, TIMEFRAME, START_DATE, END_DATE
)

df = pd.DataFrame(klines, columns=[
    "open_time","open","high","low","close","volume",
    "close_time","qav","trades","tb_base","tb_quote","ignore"
])

df["open_time"] = pd.to_datetime(df["open_time"], unit="ms")
df["open"] = df["open"].astype(float)
df["close"] = df["close"].astype(float)

df = indicators(df)
df.dropna(inplace=True)

# ========== BACKTEST ENGINE ==========
balance = START_BALANCE
position = None  # long / short
entry_price = 0
trades = []

for i in range(1, len(df)):
    row = df.iloc[i]
    prev = df.iloc[i - 1]

    price = row["open"]  # execute at next candle open

    capital = balance * RISK_PERCENT * LEVERAGE
    qty = capital / price

    long_signal = (
        prev["EMA_S"] > prev["EMA_L"]
        and prev["RSI"] > 50
        and prev["MACD"] > 0
    )

    short_signal = (
        prev["EMA_S"] < prev["EMA_L"]
        and prev["RSI"] < 50
        and prev["MACD"] < 0
    )

    # ---- ENTRY ----
    if position is None:
        if long_signal:
            position = "long"
            entry_price = price
            entry_qty = qty
        elif short_signal:
            position = "short"
            entry_price = price
            entry_qty = qty

    # ---- REVERSAL ----
    elif position == "long" and short_signal:
        pnl = (price - entry_price) * entry_qty
        balance += pnl
        trades.append(pnl)

        position = "short"
        entry_price = price
        entry_qty = qty

    elif position == "short" and long_signal:
        pnl = (entry_price - price) * entry_qty
        balance += pnl
        trades.append(pnl)

        position = "long"
        entry_price = price
        entry_qty = qty

# ========== RESULTS ==========
total_trades = len(trades)
wins = sum(1 for t in trades if t > 0)
losses = total_trades - wins
net_pnl = balance - START_BALANCE
winrate = (wins / total_trades) * 100 if total_trades > 0 else 0

print("========== BACKTEST RESULT ==========")
print(f"Symbol       : {SYMBOL}")
print(f"Trades       : {total_trades}")
print(f"Wins         : {wins}")
print(f"Losses       : {losses}")
print(f"Win Rate     : {winrate:.2f}%")
print(f"Start Balance: ${START_BALANCE:.2f}")
print(f"End Balance  : ${balance:.2f}")
print(f"Net PnL      : ${net_pnl:.2f}")
